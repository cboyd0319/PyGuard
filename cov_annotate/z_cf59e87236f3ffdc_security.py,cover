> """
> Security vulnerability fixes for Python code.
  
> Detects and fixes common security issues based on Bandit and best practices.
> """
  
> import re
> from pathlib import Path
> from typing import Dict, List, Tuple
  
> from pyguard.lib.ast_analyzer import ASTAnalyzer, SecurityIssue
> from pyguard.lib.core import FileOperations, PyGuardLogger
  
  
> class SecurityFixer:
>     """Automatically fix common Python security vulnerabilities."""
  
>     def __init__(self):
>         """Initialize security fixer."""
>         self.logger = PyGuardLogger()
>         self.file_ops = FileOperations()
>         self.fixes_applied = []
>         self.ast_analyzer = ASTAnalyzer()
  
>     def scan_file_for_issues(self, file_path: Path) -> List[SecurityIssue]:
>         """
>         Scan a file for security issues using AST analysis.
  
>         Args:
>             file_path: Path to Python file
  
>         Returns:
>             List of security issues found
>         """
>         security_issues, _ = self.ast_analyzer.analyze_file(file_path)
>         return security_issues
  
>     def fix_file(self, file_path: Path) -> Tuple[bool, List[str]]:
>         """
>         Apply security fixes to a Python file.
  
>         Args:
>             file_path: Path to Python file
  
>         Returns:
>             Tuple of (success, list of fixes applied)
>         """
>         content = self.file_ops.read_file(file_path)
>         if content is None:
!             return False, []
  
>         original_content = content
>         self.fixes_applied = []
  
          # Apply security fixes
>         content = self._fix_hardcoded_passwords(content)
>         content = self._fix_sql_injection(content)
>         content = self._fix_command_injection(content)
>         content = self._fix_insecure_random(content)
>         content = self._fix_insecure_temp_files(content)
>         content = self._fix_yaml_load(content)
>         content = self._fix_pickle_usage(content)
>         content = self._fix_eval_exec(content)
>         content = self._fix_weak_crypto(content)
>         content = self._fix_path_traversal(content)
  
          # Write back if changes were made
>         if content != original_content:
>             success = self.file_ops.write_file(file_path, content)
>             if success:
>                 self.logger.success(
>                     f"Applied {len(self.fixes_applied)} security fixes",
>                     category="Security",
>                     file_path=str(file_path),
>                     details={"fixes": self.fixes_applied},
>                 )
>             return success, self.fixes_applied
  
>         return True, []
  
>     def _fix_hardcoded_passwords(self, content: str) -> str:
>         """Fix hardcoded passwords and secrets."""
          # Pattern to detect hardcoded passwords
>         patterns = [
>             (r'password\s*=\s*["\']([^"\']+)["\']', "PASSWORD"),
>             (r'api_key\s*=\s*["\']([^"\']+)["\']', "API_KEY"),
>             (r'secret\s*=\s*["\']([^"\']+)["\']', "SECRET"),
>             (r'token\s*=\s*["\']([^"\']+)["\']', "TOKEN"),
>         ]
  
>         for pattern, var_type in patterns:
>             matches = re.finditer(pattern, content, re.IGNORECASE)
>             for match in matches:
>                 if match.group(1) not in ["", "None", "null"]:
                      # Add comment warning
>                     old_line = match.group(0)
>                     new_line = f"{old_line}  # SECURITY: Use environment variables or config files"
  
>                     if old_line in content and "# SECURITY:" not in content:
>                         content = content.replace(old_line, new_line, 1)
>                         self.fixes_applied.append(
>                             f"Added security warning for hardcoded {var_type}"
>                         )
  
>         return content
  
>     def _fix_sql_injection(self, content: str) -> str:
>         """Fix potential SQL injection vulnerabilities."""
          # Pattern: cursor.execute("SELECT * FROM users WHERE id = " + user_id)
>         pattern = r'\.execute\s*\(\s*["\'].*?["\']?\s*\+\s*.*?\)'
  
>         if re.search(pattern, content):
              # Add comment warning
!             lines = content.split("\n")
!             for i, line in enumerate(lines):
!                 if re.search(pattern, line) and "# SQL INJECTION RISK" not in line:
!                     lines[i] = f"{line}  # SQL INJECTION RISK: Use parameterized queries"
!                     self.fixes_applied.append("Added SQL injection warning")
!             content = "\n".join(lines)
  
>         return content
  
>     def _fix_command_injection(self, content: str) -> str:
>         """Fix command injection vulnerabilities."""
          # Pattern: os.system() with variable
>         patterns = [
>             r"os\.system\(",
>             r"subprocess\.call\([^,\)]*%",
>             r"subprocess\.Popen\([^,\)]*\+",
>         ]
  
>         lines = content.split("\n")
>         for pattern in patterns:
>             for i, line in enumerate(lines):
>                 if re.search(pattern, line):
                      # Check if shell=True is used
!                     if "shell=True" in line and "# COMMAND INJECTION" not in line:
!                         lines[i] = f"{line}  # COMMAND INJECTION RISK: Avoid shell=True"
!                         self.fixes_applied.append("Added command injection warning")
!                     elif "os.system" in line and "# COMMAND INJECTION" not in line:
!                         lines[i] = f"{line}  # SECURITY: Use subprocess.run() instead"
!                         self.fixes_applied.append("Added os.system() warning")
  
>         return "\n".join(lines)
  
>     def _fix_insecure_random(self, content: str) -> str:
>         """Fix usage of insecure random number generators."""
          # Replace random with secrets for security-sensitive operations
>         if "import random" in content and "password" in content.lower():
!             if "import secrets" not in content:
!                 content = content.replace(
!                     "import random",
!                     "import random\nimport secrets  # Use secrets for cryptographic randomness",
!                 )
!                 self.fixes_applied.append("Added secrets import for secure random")
  
          # Warn about random.random() in security contexts
>         lines = content.split("\n")
>         for i, line in enumerate(lines):
>             if "random." in line and any(
>                 word in line.lower() for word in ["password", "token", "key", "secret"]
>             ):
!                 if "# SECURITY:" not in line:
!                     lines[i] = (
!                         f"{line}  # SECURITY: Use secrets module for cryptographic randomness"
!                     )
!                     self.fixes_applied.append("Added warning about insecure random usage")
  
>         return "\n".join(lines)
  
>     def _fix_insecure_temp_files(self, content: str) -> str:
>         """Fix insecure temporary file creation."""
          # Replace tempfile.mktemp() with tempfile.mkstemp()
>         if "tempfile.mktemp(" in content:
!             content = content.replace(
!                 "tempfile.mktemp(",
!                 "tempfile.mkstemp(  # FIXED: Using secure mkstemp() instead of mktemp()",
!             )
!             self.fixes_applied.append("Replaced mktemp() with mkstemp()")
  
>         return content
  
>     def _fix_yaml_load(self, content: str) -> str:
>         """Fix unsafe YAML loading."""
          # Replace yaml.load() with yaml.safe_load()
>         if "yaml.load(" in content and "yaml.safe_load(" not in content:
!             content = re.sub(r"yaml\.load\(", "yaml.safe_load(", content)
!             self.fixes_applied.append("Replaced yaml.load() with yaml.safe_load()")
  
>         return content
  
>     def _fix_pickle_usage(self, content: str) -> str:
>         """Warn about pickle usage with untrusted data."""
>         if "pickle.load" in content or "pickle.loads" in content:
!             lines = content.split("\n")
!             for i, line in enumerate(lines):
!                 if "pickle.load" in line and "# SECURITY:" not in line:
!                     lines[i] = f"{line}  # SECURITY: Don't use pickle with untrusted data"
!                     self.fixes_applied.append("Added pickle security warning")
!             content = "\n".join(lines)
  
>         return content
  
>     def _fix_eval_exec(self, content: str) -> str:
>         """Warn about dangerous eval() and exec() usage."""
>         dangerous_funcs = ["eval(", "exec(", "compile("]
  
>         lines = content.split("\n")
>         for func in dangerous_funcs:
>             for i, line in enumerate(lines):
>                 if func in line and "# DANGEROUS:" not in line and not line.strip().startswith("#"):
!                     lines[i] = f"{line}  # DANGEROUS: Avoid {func.rstrip('(')} with untrusted input"
!                     self.fixes_applied.append(f"Added warning about {func.rstrip('(')}")
  
>         return "\n".join(lines)
  
>     def _fix_weak_crypto(self, content: str) -> str:
>         """Fix weak cryptographic practices."""
          # Replace MD5/SHA1 with SHA256
>         weak_hashes = {
>             "hashlib.md5(": "hashlib.sha256(",
>             "hashlib.sha1(": "hashlib.sha256(",
>         }
  
>         for weak, strong in weak_hashes.items():
>             if weak in content:
!                 lines = content.split("\n")
!                 for i, line in enumerate(lines):
!                     if weak in line and "SECURITY:" not in line:
!                         lines[i] = f"{line}  # SECURITY: Consider using SHA256 or stronger"
!                         self.fixes_applied.append(f"Added warning about {weak}")
!                 content = "\n".join(lines)
  
>         return content
  
>     def _fix_path_traversal(self, content: str) -> str:
>         """Fix potential path traversal vulnerabilities."""
          # Warn about direct path joins with user input
>         if "os.path.join" in content:
!             lines = content.split("\n")
!             for i, line in enumerate(lines):
!                 if "os.path.join" in line and any(
!                     var in line for var in ["input", "request", "user", "param"]
!                 ):
!                     if "# PATH TRAVERSAL" not in line:
!                         lines[i] = f"{line}  # PATH TRAVERSAL RISK: Validate and sanitize paths"
!                         self.fixes_applied.append("Added path traversal warning")
!             content = "\n".join(lines)
  
>         return content
  
>     def scan_file_for_issues_legacy(self, file_path: Path) -> List[Dict[str, str]]:
>         """
>         Scan file for security issues using regex patterns (legacy method).
  
>         Args:
>             file_path: Path to Python file
  
>         Returns:
>             List of security issues found as dictionaries
>         """
!         content = self.file_ops.read_file(file_path)
!         if content is None:
!             return []
  
!         issues = []
  
          # Check for various security issues
!         checks = [
!             (r'password\s*=\s*["\'][^"\']+["\']', "Hardcoded password detected"),
!             (r"\.execute\s*\([^)]*\+", "Potential SQL injection"),
!             (r"shell=True", "Command injection risk with shell=True"),
!             (r"eval\(", "Dangerous eval() usage"),
!             (r"pickle\.loads?\(", "Unsafe pickle usage"),
!             (r"yaml\.load\(", "Unsafe YAML loading"),
!             (r"random\.", "Insecure random in security context"),
!         ]
  
!         for pattern, description in checks:
!             if re.search(pattern, content):
!                 issues.append(
!                     {
!                         "file": str(file_path),
!                         "issue": description,
!                         "severity": "HIGH",
!                     }
!                 )
  
!         return issues
