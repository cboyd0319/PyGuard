> """
> Advanced Security Analysis for PyGuard.
  
> Implements cutting-edge security detection capabilities including:
> - Taint tracking and data flow analysis
> - ReDoS (Regular Expression Denial of Service) detection
> - Race condition detection
> - Integer overflow/underflow detection
> - Supply chain security analysis
> - Advanced cryptographic vulnerability detection
  
> References:
> - OWASP ASVS v5.0 | https://owasp.org/ASVS | High | Application Security Verification Standard
> - CWE Top 25 | https://cwe.mitre.org/top25/ | High | Common Weakness Enumeration
> - NIST SSDF | https://csrc.nist.gov/publications/detail/sp/800-218/final | High | Secure Software Development Framework
> - SANS Top 25 | https://www.sans.org/top25-software-errors/ | High | Most Dangerous Software Errors
> - MITRE ATT&CK | https://attack.mitre.org/ | Medium | Adversarial Tactics, Techniques & Common Knowledge
> """
  
> import ast
> import re
> from dataclasses import dataclass
> from pathlib import Path
> from typing import Dict, List, Optional, Tuple
  
> from pyguard.lib.ast_analyzer import SecurityIssue
> from pyguard.lib.core import FileOperations, PyGuardLogger
  
  
> @dataclass
> class TaintedVariable:
>     """Represents a variable that may contain untrusted data."""
  
>     name: str
>     source: str  # user_input, network, file, etc.
>     line_number: int
>     taint_level: str  # HIGH, MEDIUM, LOW
  
  
> class TaintAnalyzer(ast.NodeVisitor):
>     """
>     Taint tracking analyzer for data flow security.
  
>     Tracks untrusted data from sources (user input, network, files) to sinks
>     (SQL queries, OS commands, eval, etc.) to detect injection vulnerabilities.
  
>     Aligned with OWASP ASVS-5.1.1: Input Validation Architecture
>     """
  
      # Sources of untrusted data
>     TAINT_SOURCES = {
>         "input": "user_input",
>         "sys.argv": "command_line",
>         "os.environ": "environment",
>         "request.args": "http_request",
>         "request.form": "http_request",
>         "request.json": "http_request",
>         "request.data": "http_request",
>         "socket.recv": "network",
>         "open": "file",
>     }
  
      # Dangerous sinks that shouldn't receive tainted data
>     DANGEROUS_SINKS = {
>         "eval",
>         "exec",
>         "compile",
>         "os.system",
>         "subprocess.call",
>         "subprocess.run",
>         "subprocess.Popen",
>     }
  
>     def __init__(self, source_lines: List[str]):
>         """Initialize taint analyzer."""
!         self.issues: List[SecurityIssue] = []
!         self.source_lines = source_lines
!         self.tainted_vars: Dict[str, TaintedVariable] = {}
  
>     def _get_code_snippet(self, node: ast.AST) -> str:
>         """Extract code snippet for a node."""
!         if hasattr(node, "lineno") and 0 < node.lineno <= len(self.source_lines):
!             return str(self.source_lines[node.lineno - 1].strip())
!         return ""
  
>     def visit_Assign(self, node: ast.Assign):
>         """Track variable assignments from tainted sources."""
!         if isinstance(node.value, ast.Call):
!             call_name = self._get_call_name(node.value)
  
              # Check if assigning from a taint source
!             for source_pattern, source_type in self.TAINT_SOURCES.items():
!                 if call_name.startswith(source_pattern):
                      # Mark all assigned variables as tainted
!                     for target in node.targets:
!                         if isinstance(target, ast.Name):
!                             self.tainted_vars[target.id] = TaintedVariable(
!                                 name=target.id,
!                                 source=source_type,
!                                 line_number=node.lineno,
!                                 taint_level="HIGH",
!                             )
  
!         self.generic_visit(node)
  
>     def visit_Call(self, node: ast.Call):
>         """Check if tainted data flows into dangerous sinks."""
!         func_name = self._get_call_name(node)
  
          # Check if calling a dangerous sink
!         if func_name in self.DANGEROUS_SINKS:
              # Check if any argument is tainted
!             for arg in node.args:
!                 if isinstance(arg, ast.Name) and arg.id in self.tainted_vars:
!                     tainted = self.tainted_vars[arg.id]
!                     self.issues.append(
!                         SecurityIssue(
!                             severity="CRITICAL",
!                             category="Taint Flow Violation",
!                             message=f"Untrusted data from {tainted.source} flows into {func_name}()",
!                             line_number=node.lineno,
!                             column=node.col_offset,
!                             code_snippet=self._get_code_snippet(node),
!                             fix_suggestion=f"Sanitize/validate input from {tainted.source} before passing to {func_name}()",
!                             owasp_id="ASVS-5.1.1",
!                             cwe_id="CWE-20",
!                         )
!                     )
  
!         self.generic_visit(node)
  
>     def _get_call_name(self, node: ast.Call) -> str:
>         """Get the full name of a function call."""
!         if isinstance(node.func, ast.Name):
!             return node.func.id
!         elif isinstance(node.func, ast.Attribute):
!             parts = []
!             current: ast.expr = node.func
!             while isinstance(current, ast.Attribute):
!                 parts.append(current.attr)
!                 current = current.value
!             if isinstance(current, ast.Name):
!                 parts.append(current.id)
!             return ".".join(reversed(parts))
!         return ""
  
  
> class ReDoSDetector:
>     """
>     Regular Expression Denial of Service (ReDoS) detector.
  
>     Detects regex patterns vulnerable to catastrophic backtracking that can
>     cause excessive CPU usage and denial of service.
  
>     References:
>     - OWASP ASVS-5.1.5: Regular Expression Validation
>     - CWE-1333: Inefficient Regular Expression Complexity
>     """
  
      # Patterns that indicate potential ReDoS vulnerability
>     REDOS_PATTERNS = [
>         r"\(.*\+.*\)\+",  # Nested quantifiers: (a+)+
>         r"\(.*\*.*\)\+",  # Nested quantifiers: (a*)+
>         r"\(.*\+.*\)\*",  # Nested quantifiers: (a+)*
>         r"\(.*\*.*\)\*",  # Nested quantifiers: (a*)*
>         r"\(.*\|.*\)\+",  # Alternation with quantifier
>     ]
  
>     def __init__(self):
>         """Initialize ReDoS detector."""
!         self.logger = PyGuardLogger()
  
>     def analyze_regex(
>         self, pattern: str, line_number: int, code_snippet: str
>     ) -> Optional[SecurityIssue]:
>         """Analyze a regex pattern for ReDoS vulnerabilities."""
!         for redos_pattern in self.REDOS_PATTERNS:
!             if re.search(redos_pattern, pattern):
!                 return SecurityIssue(
!                     severity="HIGH",
!                     category="Regular Expression DoS",
!                     message=f"Regex pattern vulnerable to ReDoS attack: {pattern[:50]}...",
!                     line_number=line_number,
!                     column=0,
!                     code_snippet=code_snippet,
!                     fix_suggestion="Simplify regex pattern, avoid nested quantifiers, or use re2 library",
!                     owasp_id="ASVS-5.1.5",
!                     cwe_id="CWE-1333",
!                 )
!         return None
  
  
> class RaceConditionDetector(ast.NodeVisitor):
>     """
>     Race condition detector for TOCTOU (Time-of-check to Time-of-use) vulnerabilities.
  
>     Detects patterns where file existence/permissions are checked before use,
>     creating a window for race conditions.
  
>     References:
>     - CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization
>     - CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition
>     """
  
>     def __init__(self, source_lines: List[str]):
>         """Initialize race condition detector."""
!         self.issues: List[SecurityIssue] = []
!         self.source_lines = source_lines
!         self.file_checks: List[Tuple[int, str]] = []  # (line_number, variable)
  
>     def _get_code_snippet(self, node: ast.AST) -> str:
>         """Extract code snippet for a node."""
!         if hasattr(node, "lineno") and 0 < node.lineno <= len(self.source_lines):
!             return str(self.source_lines[node.lineno - 1].strip())
!         return ""
  
>     def visit_Call(self, node: ast.Call):
>         """Detect TOCTOU patterns."""
!         func_name = self._get_call_name(node)
  
          # Track file existence checks
!         if func_name in ["os.path.exists", "os.path.isfile", "os.access"]:
!             if node.args and isinstance(node.args[0], ast.Name):
!                 self.file_checks.append((node.lineno, node.args[0].id))
  
          # Check for file operations that might follow a check
!         if func_name in ["open", "os.remove", "os.unlink", "os.chmod"]:
!             if node.args and isinstance(node.args[0], ast.Name):
!                 file_var = node.args[0].id
                  # Look for recent file checks on same variable
!                 for check_line, check_var in self.file_checks:
!                     if check_var == file_var and (node.lineno - check_line) < 10:
!                         self.issues.append(
!                             SecurityIssue(
!                                 severity="MEDIUM",
!                                 category="Race Condition (TOCTOU)",
!                                 message=f"File check at line {check_line} followed by operation - potential race condition",
!                                 line_number=node.lineno,
!                                 column=node.col_offset,
!                                 code_snippet=self._get_code_snippet(node),
!                                 fix_suggestion="Use exception handling instead of checking file existence first",
!                                 owasp_id="ASVS-1.4.2",
!                                 cwe_id="CWE-367",
!                             )
!                         )
  
!         self.generic_visit(node)
  
>     def _get_call_name(self, node: ast.Call) -> str:
>         """Get the full name of a function call."""
!         if isinstance(node.func, ast.Name):
!             return node.func.id
!         elif isinstance(node.func, ast.Attribute):
!             parts = []
!             current: ast.expr = node.func
!             while isinstance(current, ast.Attribute):
!                 parts.append(current.attr)
!                 current = current.value
!             if isinstance(current, ast.Name):
!                 parts.append(current.id)
!             return ".".join(reversed(parts))
!         return ""
  
  
> class IntegerSecurityAnalyzer(ast.NodeVisitor):
>     """
>     Integer overflow/underflow and numeric security analyzer.
  
>     Detects potential integer security issues that could lead to:
>     - Buffer overflows
>     - Memory corruption
>     - Logic errors
>     - Security bypass
  
>     References:
>     - CWE-190: Integer Overflow or Wraparound
>     - CWE-191: Integer Underflow
>     - CWE-682: Incorrect Calculation
>     """
  
>     def __init__(self, source_lines: List[str]):
>         """Initialize integer security analyzer."""
!         self.issues: List[SecurityIssue] = []
!         self.source_lines = source_lines
  
>     def _get_code_snippet(self, node: ast.AST) -> str:
>         """Extract code snippet for a node."""
!         if hasattr(node, "lineno") and 0 < node.lineno <= len(self.source_lines):
!             return str(self.source_lines[node.lineno - 1].strip())
!         return ""
  
>     def visit_BinOp(self, node: ast.BinOp):
>         """Check for potentially unsafe integer operations."""
          # Check for multiplication that could overflow
!         if isinstance(node.op, ast.Mult):
              # If both operands are not constants, could overflow
!             if not (isinstance(node.left, ast.Constant) and isinstance(node.right, ast.Constant)):
                  # Look for array/buffer sizing operations
!                 parent = getattr(node, "parent", None)
!                 if parent and isinstance(parent, (ast.Subscript, ast.Call)):
!                     self.issues.append(
!                         SecurityIssue(
!                             severity="MEDIUM",
!                             category="Integer Overflow Risk",
!                             message="Unchecked multiplication could cause integer overflow in memory allocation",
!                             line_number=node.lineno,
!                             column=node.col_offset,
!                             code_snippet=self._get_code_snippet(node),
!                             fix_suggestion="Validate operands are within safe ranges before multiplication",
!                             owasp_id="ASVS-5.1.4",
!                             cwe_id="CWE-190",
!                         )
!                     )
  
!         self.generic_visit(node)
  
  
> class AdvancedSecurityAnalyzer:
>     """
>     Main class for advanced security analysis.
  
>     Coordinates all advanced detection modules to provide comprehensive
>     security analysis beyond basic pattern matching.
>     """
  
>     def __init__(self):
>         """Initialize advanced security analyzer."""
!         self.logger = PyGuardLogger()
!         self.file_ops = FileOperations()
!         self.redos_detector = ReDoSDetector()
  
>     def analyze_file(self, file_path: Path) -> List[SecurityIssue]:
>         """
>         Perform advanced security analysis on a file.
  
>         Args:
>             file_path: Path to Python file
  
>         Returns:
>             List of security issues found
>         """
!         content = self.file_ops.read_file(file_path)
!         if content is None:
!             return []
  
!         return self.analyze_code(content)
  
>     def analyze_code(self, source_code: str) -> List[SecurityIssue]:
>         """
>         Perform advanced security analysis on source code.
  
>         Args:
>             source_code: Python source code string
  
>         Returns:
>             List of security issues found
>         """
!         try:
!             tree = ast.parse(source_code)
!         except SyntaxError:
!             return []
  
!         source_lines = source_code.split("\n")
!         all_issues = []
  
          # Run taint analysis
!         taint_analyzer = TaintAnalyzer(source_lines)
!         taint_analyzer.visit(tree)
!         all_issues.extend(taint_analyzer.issues)
  
          # Run race condition detection
!         race_detector = RaceConditionDetector(source_lines)
!         race_detector.visit(tree)
!         all_issues.extend(race_detector.issues)
  
          # Run integer security analysis
!         int_analyzer = IntegerSecurityAnalyzer(source_lines)
!         int_analyzer.visit(tree)
!         all_issues.extend(int_analyzer.issues)
  
          # Run ReDoS detection on regex patterns
!         for node in ast.walk(tree):
!             if isinstance(node, ast.Call):
!                 func_name = self._get_call_name(node)
!                 if func_name in ["re.compile", "re.match", "re.search", "re.findall"]:
!                     if node.args and isinstance(node.args[0], ast.Constant):
!                         pattern = node.args[0].value
!                         if isinstance(pattern, str):
!                             redos_issue = self.redos_detector.analyze_regex(
!                                 pattern, node.lineno, source_lines[node.lineno - 1].strip()
!                             )
!                             if redos_issue:
!                                 all_issues.append(redos_issue)
  
!         return all_issues
  
>     def _get_call_name(self, node: ast.Call) -> str:
>         """Get the full name of a function call."""
!         if isinstance(node.func, ast.Name):
!             return node.func.id
!         elif isinstance(node.func, ast.Attribute):
!             parts = []
!             current: ast.expr = node.func
!             while isinstance(current, ast.Attribute):
!                 parts.append(current.attr)
!                 current = current.value
!             if isinstance(current, ast.Name):
!                 parts.append(current.id)
!             return ".".join(reversed(parts))
!         return ""
