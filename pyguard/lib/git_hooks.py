"""Git hooks integration for PyGuard.

This module provides functionality to install, validate, and manage
PyGuard as a git pre-commit hook for automatic code quality checks.
"""

import os
import shutil
import subprocess
from pathlib import Path
from typing import Optional

from pyguard.lib.core import PyGuardLogger


class GitHooksManager:
    """Manager for PyGuard git hooks installation and configuration."""

    def __init__(self, repo_path: Optional[Path] = None):
        """Initialize the git hooks manager.

        Args:
            repo_path: Path to git repository (defaults to current directory)
        """
        self.logger = PyGuardLogger()
        self.repo_path = repo_path or Path.cwd()
        self.git_dir = self._find_git_dir()
        self.hooks_dir = self.git_dir / "hooks" if self.git_dir else None

    def _find_git_dir(self) -> Optional[Path]:
        """Find the .git directory in current or parent directories.

        Returns:
            Path to .git directory or None if not found
        """
        current = self.repo_path.resolve()
        
        # Check current directory and parents
        while current != current.parent:
            git_dir = current / ".git"
            if git_dir.exists():
                # Handle both .git directory and .git file (worktrees)
                if git_dir.is_dir():
                    return git_dir
                elif git_dir.is_file():
                    # Read gitdir from .git file
                    content = git_dir.read_text().strip()
                    if content.startswith("gitdir: "):
                        gitdir_path = content[8:]  # Remove "gitdir: " prefix
                        return Path(gitdir_path)
            current = current.parent
        
        return None

    def is_git_repository(self) -> bool:
        """Check if current directory is a git repository.

        Returns:
            True if in a git repository
        """
        return self.git_dir is not None

    def install_hook(self, hook_type: str = "pre-commit", force: bool = False) -> bool:
        """Install PyGuard as a git hook.

        Args:
            hook_type: Type of git hook (pre-commit, pre-push, etc.)
            force: Overwrite existing hook if True

        Returns:
            True if installation successful

        Raises:
            ValueError: If not in a git repository
        """
        if not self.is_git_repository():
            raise ValueError("Not in a git repository. Run 'git init' first.")

        if not self.hooks_dir:
            raise ValueError("Git hooks directory not found")

        hook_path = self.hooks_dir / hook_type
        
        # Check if hook already exists
        if hook_path.exists() and not force:
            self.logger.warning(
                f"Hook already exists: {hook_path}",
                category="GitHooks",
                details={"action": "Use --force to overwrite"}
            )
            return False

        # Create hooks directory if it doesn't exist
        self.hooks_dir.mkdir(parents=True, exist_ok=True)

        # Generate hook script
        hook_content = self._generate_hook_script(hook_type)
        
        # Write hook file
        hook_path.write_text(hook_content)
        
        # Make hook executable
        hook_path.chmod(0o755)
        
        self.logger.info(
            f"Installed PyGuard {hook_type} hook",
            category="GitHooks",
            details={"path": str(hook_path)}
        )
        
        return True

    def _generate_hook_script(self, hook_type: str) -> str:
        """Generate git hook script content.

        Args:
            hook_type: Type of git hook

        Returns:
            Hook script content
        """
        if hook_type == "pre-commit":
            return """#!/usr/bin/env bash
# PyGuard pre-commit hook
# Auto-generated by PyGuard

set -e

# Get list of staged Python files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep '\\.py$' || true)

if [ -z "$STAGED_FILES" ]; then
    echo "No Python files staged for commit"
    exit 0
fi

echo "Running PyGuard security and quality checks..."

# Run PyGuard on staged files
pyguard --scan-only $STAGED_FILES

if [ $? -ne 0 ]; then
    echo "PyGuard found issues. Fix them before committing."
    echo "To skip this check, use: git commit --no-verify"
    exit 1
fi

echo "PyGuard checks passed ✓"
exit 0
"""
        elif hook_type == "pre-push":
            return """#!/usr/bin/env bash
# PyGuard pre-push hook
# Auto-generated by PyGuard

set -e

echo "Running PyGuard comprehensive analysis before push..."

# Run PyGuard on entire codebase
pyguard --scan-only .

if [ $? -ne 0 ]; then
    echo "PyGuard found issues. Fix them before pushing."
    echo "To skip this check, use: git push --no-verify"
    exit 1
fi

echo "PyGuard checks passed ✓"
exit 0
"""
        else:
            raise ValueError(f"Unsupported hook type: {hook_type}")

    def uninstall_hook(self, hook_type: str = "pre-commit") -> bool:
        """Uninstall PyGuard git hook.

        Args:
            hook_type: Type of git hook to uninstall

        Returns:
            True if uninstallation successful
        """
        if not self.is_git_repository():
            self.logger.warning(
                "Not in a git repository",
                category="GitHooks"
            )
            return False

        if not self.hooks_dir:
            return False

        hook_path = self.hooks_dir / hook_type
        
        if not hook_path.exists():
            self.logger.warning(
                f"Hook not found: {hook_path}",
                category="GitHooks"
            )
            return False

        # Verify it's a PyGuard hook before removing
        content = hook_path.read_text()
        if "PyGuard" not in content:
            self.logger.warning(
                f"Hook at {hook_path} is not a PyGuard hook",
                category="GitHooks",
                details={"action": "Skipping removal for safety"}
            )
            return False

        # Remove hook
        hook_path.unlink()
        
        self.logger.info(
            f"Uninstalled PyGuard {hook_type} hook",
            category="GitHooks"
        )
        
        return True

    def list_hooks(self) -> list[dict[str, str | bool]]:
        """List all installed git hooks.

        Returns:
            List of hook information dictionaries
        """
        if not self.hooks_dir or not self.hooks_dir.exists():
            return []

        hooks: list[dict[str, str | bool]] = []
        for hook_file in self.hooks_dir.iterdir():
            if hook_file.is_file() and not hook_file.name.endswith(".sample"):
                content = hook_file.read_text()
                is_pyguard = "PyGuard" in content
                hooks.append({
                    "name": hook_file.name,
                    "path": str(hook_file),
                    "pyguard": is_pyguard,
                    "executable": os.access(hook_file, os.X_OK)
                })
        
        return hooks

    def validate_hook(self, hook_type: str = "pre-commit") -> dict[str, bool | str | list[str]]:
        """Validate that a git hook is properly installed and functional.

        Args:
            hook_type: Type of git hook to validate

        Returns:
            Dictionary with validation results
        """
        result: dict[str, bool | str | list[str]] = {
            "exists": False,
            "executable": False,
            "is_pyguard": False,
            "valid": False,
            "path": "",
            "issues": []
        }
        issues: list[str] = []

        if not self.is_git_repository():
            issues.append("Not in a git repository")
            result["issues"] = issues
            return result

        if not self.hooks_dir:
            issues.append("Git hooks directory not found")
            result["issues"] = issues
            return result

        hook_path = self.hooks_dir / hook_type
        result["path"] = str(hook_path)

        if not hook_path.exists():
            issues.append("Hook file does not exist")
            result["issues"] = issues
            return result

        result["exists"] = True

        # Check if executable
        if not os.access(hook_path, os.X_OK):
            issues.append("Hook file is not executable")
        else:
            result["executable"] = True

        # Check if it's a PyGuard hook
        content = hook_path.read_text()
        if "PyGuard" in content:
            result["is_pyguard"] = True
        else:
            issues.append("Hook is not a PyGuard hook")

        # Check if PyGuard is available in PATH
        if shutil.which("pyguard") is None:
            issues.append("pyguard command not found in PATH")

        result["issues"] = issues
        
        # Overall validation
        result["valid"] = (
            result["exists"] and 
            result["executable"] and 
            result["is_pyguard"] and
            len(issues) == 0
        )

        return result

    def test_hook(self, hook_type: str = "pre-commit") -> bool:
        """Test a git hook by running it.

        Args:
            hook_type: Type of git hook to test

        Returns:
            True if hook executes successfully
        """
        if not self.is_git_repository():
            self.logger.error(
                "Not in a git repository",
                category="GitHooks"
            )
            return False

        validation = self.validate_hook(hook_type)
        if not validation["valid"]:
            self.logger.error(
                f"Hook validation failed: {validation['issues']}",
                category="GitHooks"
            )
            return False

        if not self.hooks_dir:
            return False
            
        hook_path = self.hooks_dir / hook_type
        
        self.logger.info(
            f"Testing {hook_type} hook...",
            category="GitHooks"
        )

        try:
            # Run hook in test mode (dry run)
            result = subprocess.run(
                [str(hook_path)],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                self.logger.info(
                    "Hook test passed",
                    category="GitHooks",
                    details={"output": result.stdout}
                )
                return True
            else:
                self.logger.warning(
                    "Hook test failed",
                    category="GitHooks",
                    details={"returncode": result.returncode, "stderr": result.stderr}
                )
                return False
                
        except subprocess.TimeoutExpired:
            self.logger.error(
                "Hook test timed out",
                category="GitHooks"
            )
            return False
        except Exception as e:
            self.logger.error(
                f"Hook test error: {e}",
                category="GitHooks"
            )
            return False


def install_git_hooks(
    repo_path: Optional[Path] = None,
    hook_type: str = "pre-commit",
    force: bool = False
) -> bool:
    """Install PyGuard git hooks.

    Args:
        repo_path: Path to git repository
        hook_type: Type of hook to install
        force: Overwrite existing hook

    Returns:
        True if installation successful
    """
    manager = GitHooksManager(repo_path)
    return manager.install_hook(hook_type, force)


def uninstall_git_hooks(
    repo_path: Optional[Path] = None,
    hook_type: str = "pre-commit"
) -> bool:
    """Uninstall PyGuard git hooks.

    Args:
        repo_path: Path to git repository
        hook_type: Type of hook to uninstall

    Returns:
        True if uninstallation successful
    """
    manager = GitHooksManager(repo_path)
    return manager.uninstall_hook(hook_type)


def validate_git_hooks(
    repo_path: Optional[Path] = None,
    hook_type: str = "pre-commit"
) -> dict[str, bool | str | list[str]]:
    """Validate PyGuard git hooks installation.

    Args:
        repo_path: Path to git repository
        hook_type: Type of hook to validate

    Returns:
        Validation results dictionary
    """
    manager = GitHooksManager(repo_path)
    return manager.validate_hook(hook_type)
